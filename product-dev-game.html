        function displayFeaturePool() {
            const pool = document.getElementById('featurePool');
            pool.innerHTML = '';
            
            // Only show features that haven't been taken by any player
            const takenFeatures = getAllPlayerFeatures();
            const availableToShow = gameState.availableFeatures.filter(feature => !takenFeatures.includes(feature));
            
            console.log(`Displaying ${availableToShow.length} available features in pool`);
            
            availableToShow.forEach(feature => {
                const tile = document.createElement('div');
                tile.className = 'feature-tile';
                tile.textContent = feature;
                tile.draggable = true;
                tile.onclick = () => addFeatureToBoard(feature);
                
                tile.ondragstart = (e) => {
                    e.dataTransfer.setData('text/plain', feature);
                };
                
                pool.appendChild(tile);
            });
        }

        function setupCursorTracking() {
            console.log('Setting up cursor tracking...');
            const stage2 = document.getElementById('stage2');
            
            stage2.addEventListener('mousemove', (e) => {
                if (gameState.stage !== 'stage2') return;
                
                gameState.mousePosition = { x: e.clientX, y: e.clientY };
                
                if (gameState.currentPlayer) {
                    const cursor = gameState.playerCursors.get(gameState.currentPlayer.id);
                    if (cursor) {
                        cursor.x = e.clientX;
                        cursor.y = e.clientY;
                    }
                }
            });
            
            stage2.addEventListener('mousedown', (e) => {
                if (gameState.stage !== 'stage2') return;
                
                gameState.isDragging = true;
                const target = e.target;
                if (target.classList.contains('feature-tile')) {
                    gameState.draggedFeature = target.textContent;
                    console.log(`Current player started dragging ${gameState.draggedFeature}`);
                }
            });
            
            stage2.addEventListener('mouseup', () => {
                if (gameState.stage !== 'stage2') return;
                
                gameState.isDragging = false;
                gameState.draggedFeature = null;
                console.log(`Current player stopped dragging`);
            });
        }<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Product Builder - Market Research Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .game-header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .game-title {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .game-subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .lobby-screen {
            background: white;
            border-radius: 15px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            text-align: center;
        }

        .countdown-container {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            margin: 20px 0;
        }

        .countdown-text {
            font-size: 1.3rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 20px;
        }

        .progress-bar-container {
            width: 100%;
            height: 12px;
            background: #e1e5e9;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            width: 0%;
            border-radius: 6px;
            transition: width 0.1s linear;
            position: relative;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .join-form {
            margin-bottom: 30px;
        }

        .input-group {
            margin: 15px 0;
        }

        .input-group input {
            width: 100%;
            max-width: 300px;
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .players-list {
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .player-item {
            display: inline-block;
            background: white;
            margin: 5px;
            padding: 8px 16px;
            border-radius: 20px;
            border: 2px solid #e1e5e9;
        }

        .player-item.admin {
            border-color: #ffd700;
            background: #fff8dc;
        }

        .game-stage {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            display: none;
        }

        .game-stage.active {
            display: block;
        }

        .stage-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .stage-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .stage-description {
            font-size: 1.1rem;
            color: #666;
            margin-bottom: 20px;
        }

        .timer {
            font-size: 1.5rem;
            font-weight: bold;
            color: #e74c3c;
            margin-bottom: 20px;
        }

        .product-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .product-option {
            border: 2px solid #e1e5e9;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8f9fa;
        }

        .product-option:hover {
            border-color: #667eea;
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }

        .product-option.selected {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .product-option h3 {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #333;
        }

        .feature-list {
            list-style: none;
        }

        .feature-list li {
            padding: 5px 0;
            color: #555;
        }

        .feature-list li:before {
            content: "✓ ";
            color: #28a745;
            font-weight: bold;
        }

        .building-area {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 30px;
            margin: 20px 0;
        }

        .feature-pool {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            min-height: 400px;
        }

        .feature-pool h3 {
            margin-bottom: 15px;
            text-align: center;
        }

        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .feature-tile {
            background: white;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            cursor: grab;
            transition: all 0.3s;
            font-size: 0.9rem;
        }

        .feature-tile:hover {
            border-color: #667eea;
            transform: scale(1.05);
        }

        .feature-tile:active {
            cursor: grabbing;
        }

        .player-board {
            background: white;
            border: 3px solid #667eea;
            border-radius: 12px;
            padding: 20px;
            min-height: 400px;
        }

        .player-board h3 {
            margin-bottom: 15px;
            text-align: center;
            color: #667eea;
        }

        .board-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            min-height: 200px;
        }

        .board-slot {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            color: #999;
            transition: all 0.3s;
        }

        .board-slot.filled {
            border: 2px solid #28a745;
            background: #f8fff8;
            color: #333;
        }

        .board-slot.can-drop {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .other-players {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .other-player {
            background: #f8f9fa;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            padding: 15px;
            position: relative;
            transition: all 0.3s;
        }

        .other-player.active {
            border-color: #667eea;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
        }

        .other-player h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .other-player-features {
            font-size: 0.8rem;
            color: #666;
        }

        .player-activity {
            font-size: 0.7rem;
            color: #667eea;
            font-style: italic;
            margin-top: 5px;
            min-height: 16px;
        }

        .cursor-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 1000;
        }

        .player-cursor {
            position: absolute;
            width: 24px;
            height: 24px;
            pointer-events: none;
            z-index: 1001;
            transform: translate(-50%, -50%);
        }

        .cursor-hand {
            font-size: 24px;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3));
            transform-origin: center;
        }

        .cursor-hand.open {
            transform: rotate(-10deg);
        }

        .cursor-hand.closed {
            transform: rotate(-10deg) scale(1.1);
        }

        .cursor-label {
            position: absolute;
            top: 25px;
            left: 0;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            white-space: nowrap;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .cursor-dragging-item {
            position: absolute;
            top: -15px;
            left: 15px;
            background: #667eea;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 9px;
            max-width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .results-screen {
            text-align: center;
        }

        .leaderboard {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 30px;
            margin: 30px 0;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            margin: 10px 0;
            background: white;
            border-radius: 8px;
            border-left: 5px solid #ccc;
        }

        .leaderboard-item.winner {
            border-left-color: #ffd700;
            background: #fff8dc;
        }

        .leaderboard-item.second {
            border-left-color: #c0c0c0;
        }

        .leaderboard-item.third {
            border-left-color: #cd7f32;
        }

        .player-score {
            font-weight: bold;
            font-size: 1.2rem;
        }

        .feature-stats {
            margin-top: 30px;
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
        }

        .hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .building-area {
                grid-template-columns: 1fr;
            }
            
            .product-options {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="game-header">
            <h1 class="game-title">Product Builder</h1>
            <p class="game-subtitle">Market Research Through Competitive Building</p>
        </div>

        <!-- Lobby Screen -->
        <div id="lobby" class="lobby-screen">
            <div class="join-form">
                <div class="input-group">
                    <input type="text" id="playerName" placeholder="Enter your name" maxlength="20">
                </div>
                <button class="btn" onclick="joinGame()">Join Game</button>
            </div>
        </div>

        <!-- Waiting Room -->
        <div id="waitingRoom" class="lobby-screen" style="display: none;">
            <h2>Waiting for Players</h2>
            <p>Room Code: <strong id="roomCodeDisplay"></strong></p>
            
            <div class="countdown-container">
                <div class="countdown-text">
                    <span id="countdownText">Game starts in 20 seconds</span>
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progressBar"></div>
                </div>
            </div>

            <div class="players-list">
                <h3>Players Ready (<span id="playerCount">0</span>/4)</h3>
                <div id="playersList"></div>
            </div>
        </div>

        <!-- Stage 1: Conjoint Test -->
        <div id="stage1" class="game-stage">
            <div class="stage-header">
                <h2 class="stage-title">Stage 1: Product Preference</h2>
                <p class="stage-description">Choose which product you would be most likely to buy</p>
                <div class="timer" id="stage1Timer">Time remaining: 30s</div>
            </div>

            <div class="product-options" id="productOptions">
                <!-- Product options will be generated here -->
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button class="btn" onclick="submitConjointChoice()" id="submitChoice" disabled>Submit Choice</button>
            </div>
        </div>

        <!-- Stage 2: Building Phase -->
        <div id="stage2" class="game-stage">
            <div class="stage-header">
                <h2 class="stage-title">Stage 2: Build Your Product</h2>
                <p class="stage-description">Grab features from the pool and build your product. Watch out - other players can steal from your board!</p>
                <div class="timer" id="stage2Timer">Time remaining: 30s</div>
            </div>

            <div class="building-area">
                <div>
                    <div class="feature-pool">
                        <h3>Available Features</h3>
                        <div class="features-grid" id="featurePool">
                            <!-- Features will be generated here -->
                        </div>
                    </div>

                    <div class="other-players" id="otherPlayers">
                        <!-- Other players' boards will be shown here -->
                    </div>
                </div>

                <div class="player-board">
                    <h3>Your Product</h3>
                    <div class="board-grid" id="playerBoard">
                        <!-- Player's board slots -->
                    </div>
                </div>
            </div>
            
            <!-- Cursor overlay for multiplayer cursors -->
            <div class="cursor-overlay" id="cursorOverlay">
                <!-- Player cursors will be added here -->
            </div>
        </div>

        <!-- Results Screen -->
        <div id="results" class="game-stage">
            <div class="stage-header">
                <h2 class="stage-title">Game Results</h2>
                <p class="stage-description">Final scores based on market preferences</p>
            </div>

            <div class="leaderboard" id="leaderboard">
                <!-- Results will be shown here -->
            </div>

            <div class="feature-stats">
                <h3>Feature Popularity Analysis</h3>
                <div class="stats-grid" id="featureStats">
                    <!-- Feature statistics will be shown here -->
                </div>
            </div>

            <div style="text-align: center; margin-top: 30px;">
                <button class="btn" onclick="newGame()">Play Again</button>
            </div>
        </div>
    </div>

    <script>
        console.log('=== FRESH GAME VERSION 2.0 LOADED ===');
        
        // Bot names
        const BOT_NAMES = [
            'TechGuru_AI', 'MarketMaven', 'ProductPro', 'InnoBot', 'DesignWiz',
            'FeatureFinder', 'BuildMaster', 'TrendSpotter', 'UserVoice', 'QualityBot'
        ];

        // Available features
        const AVAILABLE_FEATURES = [
            'Premium Materials', 'Wireless Connectivity', 'Voice Control', 'Mobile App',
            'Energy Efficient', 'Compact Design', 'Touch Screen', 'Auto Updates',
            'Cloud Storage', 'AI Assistant', '24/7 Support', 'Warranty Plus',
            'Fast Charging', 'Water Resistant', 'Customizable', 'Smart Integration',
            'Eco Friendly', 'Professional Grade', 'User Friendly', 'Advanced Security'
        ];

        // Game state - initialized after constants
        let gameState = {
            players: new Map(),
            currentPlayer: null,
            isAdmin: false,
            roomCode: null,
            stage: 'lobby',
            productOptions: [],
            selectedOption: null,
            playerBoard: [],
            featureStats: new Map(),
            timer: null,
            timeLeft: 0,
            countdownTimer: null,
            countdownStartTime: null,
            minPlayers: 4,
            waitTime: 20000,
            playerActivities: new Map(),
            playerCursors: new Map(),
            mousePosition: { x: 0, y: 0 },
            isDragging: false,
            draggedFeature: null,
            availableFeatures: [...AVAILABLE_FEATURES] // Now AVAILABLE_FEATURES is defined
        };

        function joinGame() {
            const name = document.getElementById('playerName').value.trim();
            
            if (!name) {
                alert('Please enter your name');
                return;
            }

            console.log('=== JOINING GAME (V2.0) ===');
            const finalRoomCode = generateRoomCode();
            const playerId = generatePlayerId();
            const isFirstPlayer = gameState.players.size === 0;
            
            gameState.currentPlayer = {
                id: playerId,
                name: name,
                isAdmin: isFirstPlayer,
                isBot: false,
                score: 0,
                board: [],
                conjointChoice: null
            };
            
            console.log('Created current player:', gameState.currentPlayer.name, gameState.currentPlayer.id);
            
            gameState.players.set(playerId, gameState.currentPlayer);
            gameState.isAdmin = isFirstPlayer;
            gameState.roomCode = finalRoomCode;
            
            AVAILABLE_FEATURES.forEach(feature => {
                gameState.featureStats.set(feature, { conjointSelections: 0, buildSelections: 0 });
            });
            
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('waitingRoom').style.display = 'block';
            document.getElementById('roomCodeDisplay').textContent = finalRoomCode;
            
            updateWaitingRoom();
            
            if (isFirstPlayer) {
                console.log('Starting countdown as first player');
                startCountdown();
            }
        }

        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function generatePlayerId() {
            return Math.random().toString(36).substring(2, 15);
        }

        function startCountdown() {
            gameState.countdownStartTime = Date.now();
            const duration = gameState.waitTime;
            
            gameState.countdownTimer = setInterval(() => {
                const elapsed = Date.now() - gameState.countdownStartTime;
                const remaining = Math.max(0, duration - elapsed);
                const seconds = Math.ceil(remaining / 1000);
                const progress = Math.min(100, (elapsed / duration) * 100);
                
                const countdownText = document.getElementById('countdownText');
                if (seconds > 0) {
                    countdownText.textContent = `Game starts in ${seconds} seconds`;
                } else {
                    countdownText.textContent = 'Starting game...';
                }
                
                document.getElementById('progressBar').style.width = progress + '%';
                
                if (seconds === 15 && gameState.players.size < 2) {
                    addBots(1);
                } else if (seconds === 10 && gameState.players.size < 3) {
                    addBots(1);
                } else if (seconds === 5 && gameState.players.size < 4) {
                    addBots(1);
                }
                
                if (remaining <= 0) {
                    clearInterval(gameState.countdownTimer);
                    
                    const botsNeeded = Math.max(0, 2 - gameState.players.size);
                    if (botsNeeded > 0) {
                        addBots(botsNeeded);
                        updateWaitingRoom();
                    }
                    
                    setTimeout(() => {
                        startGame();
                    }, 1000);
                }
            }, 100);
        }

        function addBots(count) {
            const availableNames = [...BOT_NAMES];
            const existingNames = Array.from(gameState.players.values()).map(p => p.name);
            const unusedNames = availableNames.filter(name => !existingNames.includes(name));
            
            for (let i = 0; i < count && i < unusedNames.length; i++) {
                const botId = generatePlayerId();
                const botName = unusedNames[i];
                
                const bot = {
                    id: botId,
                    name: botName,
                    isAdmin: false,
                    isBot: true,
                    score: 0,
                    board: [],
                    conjointChoice: null,
                    personality: {
                        riskTaking: Math.random(),
                        featurePreference: Math.random(),
                        buildSpeed: 0.3 + Math.random() * 0.4
                    }
                };
                
                gameState.players.set(botId, bot);
            }
            
            updateWaitingRoom();
            
            if (count > 0) {
                showNotification(`${count} AI player${count > 1 ? 's' : ''} joined!`);
            }
        }

        function updateWaitingRoom() {
            const playersList = document.getElementById('playersList');
            const playerCount = document.getElementById('playerCount');
            
            playersList.innerHTML = '';
            playerCount.textContent = gameState.players.size;
            
            gameState.players.forEach(player => {
                const playerElement = document.createElement('div');
                playerElement.className = `player-item ${player.isAdmin ? 'admin' : ''}`;
                let displayName = player.name;
                if (player.isAdmin) displayName += ' (You)';
                if (player.isBot) displayName += ' 🤖';
                playerElement.textContent = displayName;
                playersList.appendChild(playerElement);
            });
        }

        function startGame() {
            if (gameState.players.size < 2) return;
            
            if (gameState.countdownTimer) {
                clearInterval(gameState.countdownTimer);
            }
            
            console.log('=== STARTING GAME (V2.0) ===');
            gameState.stage = 'stage1';
            document.getElementById('waitingRoom').style.display = 'none';
            document.getElementById('stage1').classList.add('active');
            
            startStage1();
        }

        function startStage1() {
            console.log('=== STARTING STAGE 1 (V2.0) ===');
            gameState.stage = 'stage1';
            gameState.productOptions = generateProductOptions();
            displayProductOptions();
            
            setTimeout(() => {
                gameState.players.forEach(player => {
                    if (player.isBot && player.id !== gameState.currentPlayer?.id) {
                        makeBotConjointChoice(player);
                    }
                });
            }, 2000 + Math.random() * 8000);
            
            startTimer(30, 'stage1Timer', () => {
                console.log('Stage 1 timer expired, auto-submitting choice');
                if (gameState.selectedOption === null) {
                    gameState.selectedOption = 0;
                    submitConjointChoice();
                }
            });
        }

        function makeBotConjointChoice(bot) {
            let preferredOption;
            
            if (bot.personality.featurePreference < 0.3) {
                preferredOption = 0;
            } else if (bot.personality.featurePreference > 0.7) {
                preferredOption = 2;
            } else {
                preferredOption = Math.random() > 0.5 ? 1 : Math.floor(Math.random() * 3);
            }
            
            bot.conjointChoice = preferredOption;
            
            const selectedProduct = gameState.productOptions[preferredOption];
            selectedProduct.features.forEach(feature => {
                const stats = gameState.featureStats.get(feature);
                stats.conjointSelections++;
            });
        }

        function generateProductOptions() {
            const options = [];
            for (let i = 0; i < 3; i++) {
                const features = [];
                const shuffled = [...AVAILABLE_FEATURES].sort(() => 0.5 - Math.random());
                for (let j = 0; j < 5; j++) {
                    features.push(shuffled[j]);
                }
                options.push({
                    id: i,
                    name: `Product ${String.fromCharCode(65 + i)}`,
                    features: features
                });
            }
            return options;
        }

        function displayProductOptions() {
            const container = document.getElementById('productOptions');
            container.innerHTML = '';
            
            gameState.productOptions.forEach((option, index) => {
                const optionElement = document.createElement('div');
                optionElement.className = 'product-option';
                optionElement.onclick = () => selectOption(index);
                
                optionElement.innerHTML = `
                    <h3>${option.name}</h3>
                    <ul class="feature-list">
                        ${option.features.map(feature => `<li>${feature}</li>`).join('')}
                    </ul>
                `;
                
                container.appendChild(optionElement);
            });
        }

        function selectOption(optionIndex) {
            document.querySelectorAll('.product-option').forEach(el => 
                el.classList.remove('selected'));
            
            document.querySelectorAll('.product-option')[optionIndex].classList.add('selected');
            gameState.selectedOption = optionIndex;
            
            document.getElementById('submitChoice').disabled = false;
        }

        function submitConjointChoice() {
            if (gameState.selectedOption === null) return;
            
            gameState.currentPlayer.conjointChoice = gameState.selectedOption;
            
            const selectedProduct = gameState.productOptions[gameState.selectedOption];
            selectedProduct.features.forEach(feature => {
                const stats = gameState.featureStats.get(feature);
                stats.conjointSelections++;
            });
            
            console.log('=== TRANSITIONING FROM STAGE 1 TO STAGE 2 (V2.0) ===');
            console.log('Current stage before transition:', gameState.stage);
            
            setTimeout(() => {
                console.log('Timeout executing - hiding stage1, showing stage2');
                document.getElementById('stage1').classList.remove('active');
                document.getElementById('stage2').classList.add('active');
                console.log('Stage 2 UI activated, calling startBuildingPhase() V2.0');
                
                try {
                    initializeBuildingPhase();
                    console.log('initializeBuildingPhase() completed successfully');
                } catch (error) {
                    console.error('ERROR in initializeBuildingPhase():', error);
                }
            }, 1000);
        }

        function initializeBuildingPhase() {
            console.log('=== STARTING BUILDING PHASE V2.0 ===');
            console.log('Stage before setting to stage2:', gameState.stage);
            
            // CRITICAL: Set stage to stage2 FIRST
            gameState.stage = 'stage2';
            console.log('Stage after setting to stage2:', gameState.stage);
            
            gameState.playerBoard = Array(4).fill(null);
            gameState.availableFeatures = [...AVAILABLE_FEATURES]; // Reset available features
            console.log('Reset player board and available features');
            
            // Initialize all players for building
            gameState.players.forEach(player => {
                console.log(`Setting up player: ${player.name} (isBot: ${player.isBot})`);
                
                if (player.isBot) {
                    player.board = [];
                    player.boardSlots = Array(4).fill(null);
                }
                
                gameState.playerActivities.set(player.id, { 
                    action: '', 
                    feature: '', 
                    lastUpdate: Date.now() 
                });
                
                // Initialize cursor positions in the center of the screen area
                const centerX = window.innerWidth * 0.3 + Math.random() * (window.innerWidth * 0.4);
                const centerY = window.innerHeight * 0.3 + Math.random() * (window.innerHeight * 0.4);
                
                gameState.playerCursors.set(player.id, {
                    x: centerX,
                    y: centerY,
                    isDragging: false,
                    draggedItem: null,
                    isVisible: player.id !== gameState.currentPlayer?.id
                });
                
                console.log(`Initialized cursor for ${player.name} (ID: ${player.id}) at (${centerX}, ${centerY})`);
            });
            
            console.log('About to call display functions...');
            displayFeaturePool();
            displayPlayerBoard();
            displayOtherPlayers();
            setupCursorTracking();
            createPlayerCursors();
            console.log('Display functions completed');
            
            // Test cursor movement immediately
            setTimeout(() => {
                console.log('=== TESTING CURSOR MOVEMENT V2.0 ===');
                console.log('Stage during cursor test:', gameState.stage);
                testCursorMovement();
            }, 500);
            
            // Start bot building behavior
            setTimeout(() => {
                console.log('=== STARTING BOT BUILDING V2.0 ===');
                console.log('Game stage before starting bots:', gameState.stage);
                startBotBuilding();
            }, 1000);
            
            console.log('About to start 30 second timer...');
            startTimer(30, 'stage2Timer', endBuildingPhase);
            console.log('Building phase setup completed');
        }

        function testCursorMovement() {
            console.log('Testing cursor movement...');
            
            gameState.players.forEach((player, index) => {
                if (!player.isBot) return;
                
                const testX = 200 + (index * 150);
                const testY = 300 + (index * 50);
                
                console.log(`Moving ${player.name} cursor to test position (${testX}, ${testY})`);
                
                // Direct position update
                const cursor = gameState.playerCursors.get(player.id);
                if (cursor) {
                    cursor.x = testX;
                    cursor.y = testY;
                    
                    const cursorElement = document.getElementById(`cursor-${player.id}`);
                    if (cursorElement) {
                        cursorElement.style.left = testX + 'px';
                        cursorElement.style.top = testY + 'px';
                        console.log(`Updated ${player.name} cursor element to (${testX}, ${testY})`);
                    } else {
                        console.log(`ERROR: Cursor element not found for ${player.name}`);
                    }
                } else {
                    console.log(`ERROR: Cursor state not found for ${player.name}`);
                }
                
                // Test animation after initial position
                setTimeout(() => {
                    const animTestX = testX + 100;
                    const animTestY = testY + 50;
                    console.log(`Testing animation for ${player.name} to (${animTestX}, ${animTestY})`);
                    animateBotCursor(player, animTestX, animTestY, 1000);
                }, 1000 + (index * 500));
            });
        }

        function createPlayerCursors() {
            const overlay = document.getElementById('cursorOverlay');
            if (!overlay) {
                console.log('ERROR: Cursor overlay not found!');
                return;
            }
            
            overlay.innerHTML = '';
            console.log('Creating player cursors V2.0...');
            console.log('Players in game:', Array.from(gameState.players.values()).map(p => `${p.name} (${p.id}) - isBot: ${p.isBot}`));
            console.log('Current player:', gameState.currentPlayer?.name, gameState.currentPlayer?.id);
            
            const cursorEmojis = ['👆', '☝️', '👉', '👈', '👇'];
            const cursorColors = ['#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ef4444'];
            let colorIndex = 0;
            
            gameState.players.forEach(player => {
                console.log(`Checking player ${player.name} (${player.id}) - current player: ${gameState.currentPlayer?.id}`);
                
                if (player.id === gameState.currentPlayer?.id) {
                    console.log(`Skipping cursor for current player: ${player.name}`);
                    return;
                }
                
                const cursorElement = document.createElement('div');
                cursorElement.className = 'player-cursor';
                cursorElement.id = `cursor-${player.id}`;
                
                const emoji = cursorEmojis[colorIndex % cursorEmojis.length];
                const color = cursorColors[colorIndex % cursorColors.length];
                colorIndex++;
                
                const botIndicator = player.isBot ? ' 🤖' : '';
                
                cursorElement.innerHTML = `
                    <div class="cursor-hand open">${emoji}</div>
                    <div class="cursor-label" style="background-color: ${color};">${player.name}${botIndicator}</div>
                    <div class="cursor-dragging-item" style="display: none;"></div>
                `;
                
                overlay.appendChild(cursorElement);
                
                const cursor = gameState.playerCursors.get(player.id);
                if (cursor) {
                    cursorElement.style.left = cursor.x + 'px';
                    cursorElement.style.top = cursor.y + 'px';
                    console.log(`Created cursor element for ${player.name} (${player.id}) at (${cursor.x}, ${cursor.y})`);
                } else {
                    console.log(`ERROR: No cursor state found for ${player.name} (${player.id})`);
                }
            });
            
            console.log(`Created ${overlay.children.length} cursor elements total`);
            
            Array.from(overlay.children).forEach(el => {
                console.log(`Cursor element created: ${el.id}`);
            });
        }

        function animateBotCursor(bot, targetX, targetY, duration = 1000) {
            const cursor = gameState.playerCursors.get(bot.id);
            if (!cursor) {
                console.log(`ERROR: No cursor state found for bot ${bot.name}`);
                return;
            }
            
            const cursorElement = document.getElementById(`cursor-${bot.id}`);
            if (!cursorElement) {
                console.log(`ERROR: No cursor element found for bot ${bot.name}`);
                return;
            }
            
            const startX = cursor.x;
            const startY = cursor.y;
            const startTime = Date.now();
            
            // Add random waypoints for more human-like movement
            const waypoints = [];
            const distance = Math.sqrt(Math.pow(targetX - startX, 2) + Math.pow(targetY - startY, 2));
            const numWaypoints = Math.floor(distance / 200) + 1; // One waypoint per 200px
            
            for (let i = 1; i < numWaypoints; i++) {
                const progress = i / numWaypoints;
                const waypointX = startX + (targetX - startX) * progress + (Math.random() - 0.5) * 50;
                const waypointY = startY + (targetY - startY) * progress + (Math.random() - 0.5) * 50;
                waypoints.push({ x: waypointX, y: waypointY });
            }
            waypoints.push({ x: targetX, y: targetY });
            
            console.log(`Starting human-like animation for ${bot.name}: (${startX}, ${startY}) -> (${targetX}, ${targetY}) with ${waypoints.length} waypoints`);
            
            let currentWaypointIndex = 0;
            let waypointStartTime = startTime;
            let waypointStartX = startX;
            let waypointStartY = startY;
            
            function animate() {
                const elapsed = Date.now() - waypointStartTime;
                const waypointDuration = duration / waypoints.length;
                const progress = Math.min(elapsed / waypointDuration, 1);
                
                // Human-like easing with slight overshoot and correction
                let easeProgress;
                if (progress < 0.7) {
                    easeProgress = progress * 1.2; // Slightly faster start
                } else {
                    easeProgress = 0.84 + (progress - 0.7) * 0.53; // Slower finish with micro-corrections
                }
                easeProgress = Math.min(easeProgress, 1);
                
                const currentWaypoint = waypoints[currentWaypointIndex];
                const currentX = waypointStartX + (currentWaypoint.x - waypointStartX) * easeProgress;
                const currentY = waypointStartY + (currentWaypoint.y - waypointStartY) * easeProgress;
                
                // Add slight tremor for realism
                const tremorX = (Math.random() - 0.5) * 2;
                const tremorY = (Math.random() - 0.5) * 2;
                
                cursor.x = currentX + tremorX;
                cursor.y = currentY + tremorY;
                
                cursorElement.style.left = cursor.x + 'px';
                cursorElement.style.top = cursor.y + 'px';
                
                if (progress >= 1) {
                    currentWaypointIndex++;
                    if (currentWaypointIndex < waypoints.length) {
                        // Move to next waypoint
                        waypointStartTime = Date.now();
                        waypointStartX = currentX;
                        waypointStartY = currentY;
                        requestAnimationFrame(animate);
                    } else {
                        console.log(`Human-like animation complete for ${bot.name} at (${cursor.x}, ${cursor.y})`);
                    }
                } else {
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }

        function startBotBuilding() {
            console.log('Starting bot building phase V2.0...');
            console.log('Current game stage:', gameState.stage);
            
            gameState.players.forEach(player => {
                if (!player.isBot) return;
                
                console.log(`Setting up actions for bot: ${player.name} (ID: ${player.id})`);
                
                const totalActions = 5 + Math.floor(Math.random() * 3);
                
                for (let i = 0; i < totalActions; i++) {
                    const actionDelay = 2000 + (i * 4000) + Math.random() * 2000;
                    
                    setTimeout(() => {
                        console.log(`Checking action ${i + 1} for ${player.name}: stage=${gameState.stage}, board=${player.board.length}/4`);
                        
                        if (gameState.stage === 'stage2' && player.board.length < 4) {
                            console.log(`${player.name} executing action ${i + 1}/${totalActions}`);
                            performSimpleBotAction(player);
                        } else {
                            console.log(`${player.name} skipping action ${i + 1} - stage: ${gameState.stage}, board: ${player.board.length}/4`);
                        }
                    }, actionDelay);
                }
            });
        }

        function performSimpleBotAction(bot) {
            console.log(`${bot.name} performing action. Current board: [${bot.board.join(', ')}]`);
            
            if (bot.board.length >= 4) {
                console.log(`${bot.name} board is full, skipping action`);
                return;
            }
            
            // Decide whether to steal or grab from pool (30% chance to steal if others have features)
            const shouldSteal = Math.random() < 0.3;
            const playersWithFeatures = Array.from(gameState.players.values())
                .filter(p => p.id !== bot.id && p.board.length > 0);
            
            if (shouldSteal && playersWithFeatures.length > 0) {
                console.log(`${bot.name} attempting to steal`);
                performBotSteal(bot, playersWithFeatures);
                return;
            }
            
            // Try to grab from available features
            const availableFeatures = gameState.availableFeatures.filter(feature => 
                !getAllPlayerFeatures().includes(feature)
            );
            
            if (availableFeatures.length === 0) {
                console.log(`${bot.name} no available features, trying to steal instead`);
                if (playersWithFeatures.length > 0) {
                    performBotSteal(bot, playersWithFeatures);
                }
                return;
            }
            
            const chosenFeature = availableFeatures[Math.floor(Math.random() * availableFeatures.length)];
            console.log(`${bot.name} chose feature: "${chosenFeature}"`);
            
            performBotGrab(bot, chosenFeature);
        }

        function getAllPlayerFeatures() {
            const allFeatures = [];
            gameState.players.forEach(player => {
                allFeatures.push(...player.board);
            });
            return allFeatures;
        }

        function performBotSteal(bot, targetPlayers) {
            const targetPlayer = targetPlayers[Math.floor(Math.random() * targetPlayers.length)];
            const stolenFeature = targetPlayer.board[Math.floor(Math.random() * targetPlayer.board.length)];
            
            console.log(`${bot.name} stealing "${stolenFeature}" from ${targetPlayer.name}`);
            
            // Move to target player's area
            const targetElement = document.querySelector(`[data-player-id="${targetPlayer.id}"]`);
            if (!targetElement) {
                console.log(`Could not find target element for ${targetPlayer.name}`);
                return;
            }
            
            const rect = targetElement.getBoundingClientRect();
            const targetX = rect.left + rect.width / 2 + (Math.random() - 0.5) * 50;
            const targetY = rect.top + rect.height / 2 + (Math.random() - 0.5) * 50;
            
            showPlayerActivity(bot.id, 'looking', '');
            animateBotCursor(bot, targetX, targetY, 1200);
            
            setTimeout(() => {
                showPlayerActivity(bot.id, 'stealing', stolenFeature);
                
                setTimeout(() => {
                    updatePlayerCursor(bot.id, {
                        isDragging: true,
                        draggedItem: stolenFeature
                    });
                    
                    // Actually perform the steal
                    targetPlayer.board = targetPlayer.board.filter(f => f !== stolenFeature);
                    if (targetPlayer.boardSlots) {
                        const slotIndex = targetPlayer.boardSlots.indexOf(stolenFeature);
                        if (slotIndex !== -1) targetPlayer.boardSlots[slotIndex] = null;
                    }
                    
                    bot.board.push(stolenFeature);
                    if (bot.boardSlots) {
                        const emptySlot = bot.boardSlots.findIndex(slot => slot === null);
                        if (emptySlot !== -1) bot.boardSlots[emptySlot] = stolenFeature;
                    }
                    
                    const stats = gameState.featureStats.get(stolenFeature);
                    if (stats) stats.buildSelections++;
                    
                    console.log(`${bot.name} successfully stole "${stolenFeature}" from ${targetPlayer.name}`);
                    
                    // Show notifications
                    if (targetPlayer.id === gameState.currentPlayer?.id) {
                        showNotification(`${bot.name} 🤖 stole "${stolenFeature}" from you!`);
                    } else if (!targetPlayer.isBot) {
                        showNotification(`${bot.name} 🤖 stole "${stolenFeature}" from ${targetPlayer.name}!`);
                    }
                    
                    displayOtherPlayers();
                    if (targetPlayer.id === gameState.currentPlayer?.id) {
                        displayPlayerBoard();
                    }
                    
                    // Move to bot's own area
                    const botElement = document.querySelector(`[data-player-id="${bot.id}"]`);
                    if (botElement) {
                        const botRect = botElement.getBoundingClientRect();
                        animateBotCursor(bot, botRect.left + botRect.width / 2, botRect.top + botRect.height / 2, 1000);
                    }
                    
                    setTimeout(() => {
                        updatePlayerCursor(bot.id, {
                            isDragging: false,
                            draggedItem: null
                        });
                        showPlayerActivity(bot.id, 'stole', stolenFeature);
                        
                        setTimeout(() => {
                            showPlayerActivity(bot.id, '', '');
                        }, 2000);
                    }, 1000);
                    
                }, 800);
            }, 1200);
        }

        function performBotGrab(bot, chosenFeature) {
            const featurePool = document.getElementById('featurePool');
            if (!featurePool) {
                console.log('Feature pool element not found');
                return;
            }
            
            const poolRect = featurePool.getBoundingClientRect();
            const poolCenterX = poolRect.left + poolRect.width / 2 + (Math.random() - 0.5) * 200;
            const poolCenterY = poolRect.top + poolRect.height / 2 + (Math.random() - 0.5) * 100;
            
            console.log(`${bot.name} moving to feature pool area`);
            showPlayerActivity(bot.id, 'looking', '');
            animateBotCursor(bot, poolCenterX, poolCenterY, 1000);
            
            setTimeout(() => {
                console.log(`${bot.name} now looking for feature tile: "${chosenFeature}"`);
                
                const featureTiles = Array.from(document.querySelectorAll('.feature-tile'));
                const targetTile = featureTiles.find(tile => tile.textContent.trim() === chosenFeature);
                
                if (!targetTile) {
                    console.log(`${bot.name} could not find tile for "${chosenFeature}"`);
                    return;
                }
                
                const tileRect = targetTile.getBoundingClientRect();
                const tileX = tileRect.left + tileRect.width / 2 + (Math.random() - 0.5) * 20;
                const tileY = tileRect.top + tileRect.height / 2 + (Math.random() - 0.5) * 20;
                
                console.log(`${bot.name} moving to feature tile "${chosenFeature}" at (${tileX}, ${tileY})`);
                showPlayerActivity(bot.id, 'grabbing', chosenFeature);
                animateBotCursor(bot, tileX, tileY, 800);
                
                setTimeout(() => {
                    console.log(`${bot.name} starting drag of "${chosenFeature}"`);
                    updatePlayerCursor(bot.id, {
                        isDragging: true,
                        draggedItem: chosenFeature
                    });
                    
                    // Remove feature from available pool
                    gameState.availableFeatures = gameState.availableFeatures.filter(f => f !== chosenFeature);
                    
                    setTimeout(() => {
                        console.log(`${bot.name} adding "${chosenFeature}" to board`);
                        
                        bot.board.push(chosenFeature);
                        if (bot.boardSlots) {
                            const emptySlot = bot.boardSlots.findIndex(slot => slot === null);
                            if (emptySlot !== -1) {
                                bot.boardSlots[emptySlot] = chosenFeature;
                            }
                        }
                        
                        const stats = gameState.featureStats.get(chosenFeature);
                        if (stats) {
                            stats.buildSelections++;
                        }
                        
                        showPlayerActivity(bot.id, 'added', chosenFeature);
                        displayOtherPlayers();
                        displayFeaturePool(); // Update the pool to remove taken feature
                        
                        console.log(`${bot.name} successfully added "${chosenFeature}". Board now: [${bot.board.join(', ')}]`);
                        
                        const botElement = document.querySelector(`[data-player-id="${bot.id}"]`);
                        if (botElement) {
                            const botRect = botElement.getBoundingClientRect();
                            animateBotCursor(bot, botRect.left + botRect.width / 2, botRect.top + botRect.height / 2, 1000);
                        }
                        
                        setTimeout(() => {
                            console.log(`${bot.name} finished action - dropping "${chosenFeature}"`);
                            updatePlayerCursor(bot.id, {
                                isDragging: false,
                                draggedItem: null
                            });
                            showPlayerActivity(bot.id, '', '');
                        }, 1000);
                        
                    }, 500);
                    
                }, 800);
                
            }, 1000);
        }

        function updatePlayerCursor(playerId, updates) {
            const cursor = gameState.playerCursors.get(playerId);
            if (!cursor) {
                console.log(`ERROR: No cursor state found for player ${playerId}`);
                return;
            }
            
            Object.assign(cursor, updates);
            
            const cursorElement = document.getElementById(`cursor-${playerId}`);
            if (!cursorElement) {
                console.log(`ERROR: No cursor element found for player ${playerId}`);
                return;
            }
            
            if (updates.x !== undefined || updates.y !== undefined) {
                cursorElement.style.left = cursor.x + 'px';
                cursorElement.style.top = cursor.y + 'px';
            }
            
            const handElement = cursorElement.querySelector('.cursor-hand');
            const dragElement = cursorElement.querySelector('.cursor-dragging-item');
            
            if (handElement && dragElement) {
                if (cursor.isDragging && cursor.draggedItem) {
                    handElement.className = 'cursor-hand closed';
                    dragElement.textContent = cursor.draggedItem;
                    dragElement.style.display = 'block';
                    console.log(`Player ${playerId} started dragging "${cursor.draggedItem}"`);
                } else {
                    handElement.className = 'cursor-hand open';
                    dragElement.style.display = 'none';
                    if (updates.isDragging === false) {
                        console.log(`Player ${playerId} stopped dragging`);
                    }
                }
            }
        }

        function setupCursorTracking() {
            console.log('Setting up cursor tracking...');
            const stage2 = document.getElementById('stage2');
            
            stage2.addEventListener('mousemove', (e) => {
                if (gameState.stage !== 'stage2') return;
                
                gameState.mousePosition = { x: e.clientX, y: e.clientY };
                
                if (gameState.currentPlayer) {
                    const cursor = gameState.playerCursors.get(gameState.currentPlayer.id);
                    if (cursor) {
                        cursor.x = e.clientX;
                        cursor.y = e.clientY;
                    }
                }
            });
            
            stage2.addEventListener('mousedown', (e) => {
                if (gameState.stage !== 'stage2') return;
                
                gameState.isDragging = true;
                const target = e.target;
                if (target.classList.contains('feature-tile')) {
                    gameState.draggedFeature = target.textContent;
                    console.log(`Current player started dragging ${gameState.draggedFeature}`);
                }
            });
            
            stage2.addEventListener('mouseup', () => {
                if (gameState.stage !== 'stage2') return;
                
                gameState.isDragging = false;
                gameState.draggedFeature = null;
                console.log(`Current player stopped dragging`);
            });
        }

        function addFeatureToBoard(feature, slotIndex = null) {
            // Check if feature is still available
            const takenFeatures = getAllPlayerFeatures();
            if (takenFeatures.includes(feature)) {
                showNotification(`"${feature}" has already been taken!`);
                return;
            }
            
            let targetSlot = slotIndex;
            if (targetSlot === null) {
                targetSlot = gameState.playerBoard.findIndex(slot => slot === null);
            }
            
            if (targetSlot === -1) {
                showNotification('Your board is full!');
                return;
            }
            
            const currentSlot = gameState.playerBoard.findIndex(slot => slot === feature);
            if (currentSlot !== -1) {
                gameState.playerBoard[currentSlot] = null;
            }
            
            gameState.playerBoard[targetSlot] = feature;
            gameState.currentPlayer.board = gameState.playerBoard.filter(f => f);
            
            // Remove from available features
            gameState.availableFeatures = gameState.availableFeatures.filter(f => f !== feature);
            
            const stats = gameState.featureStats.get(feature);
            stats.buildSelections++;
            
            console.log(`Player added "${feature}" to board`);
            showNotification(`Added "${feature}" to your product!`);
            
            displayPlayerBoard();
            displayOtherPlayers();
            displayFeaturePool(); // Update pool to remove taken feature
        }

        function displayOtherPlayers() {
            const container = document.getElementById('otherPlayers');
            container.innerHTML = '';
            
            gameState.players.forEach(player => {
                if (player.id === gameState.currentPlayer.id) return;
                
                const playerElement = document.createElement('div');
                playerElement.className = 'other-player';
                playerElement.setAttribute('data-player-id', player.id);
                
                const features = player.board.filter(f => f).join(', ') || 'No features yet';
                const botIndicator = player.isBot ? ' 🤖' : '';
                
                playerElement.innerHTML = `
                    <h4>${player.name}${botIndicator}'s Product (${player.board.length}/4)</h4>
                    <div class="other-player-features">${features}</div>
                    <div class="player-activity"></div>
                `;
                
                // Allow stealing if they have features
                if (player.board.length > 0) {
                    playerElement.style.cursor = 'pointer';
                    playerElement.title = `Click to steal a feature from ${player.name}`;
                    playerElement.onclick = () => {
                        if (gameState.currentPlayer.board.length >= 4) {
                            showNotification('Your board is full! Cannot steal more features.');
                            return;
                        }
                        stealRandomFeature(player);
                    };
                } else {
                    playerElement.style.cursor = 'default';
                    playerElement.title = `${player.name} has no features to steal`;
                }
                
                container.appendChild(playerElement);
            });
        }

        function stealRandomFeature(targetPlayer) {
            if (targetPlayer.board.length === 0) return;
            
            const randomIndex = Math.floor(Math.random() * targetPlayer.board.length);
            const stolenFeature = targetPlayer.board[randomIndex];
            
            console.log(`Player stealing "${stolenFeature}" from ${targetPlayer.name}`);
            
            // Remove from target player
            targetPlayer.board.splice(randomIndex, 1);
            if (targetPlayer.boardSlots) {
                const slotIndex = targetPlayer.boardSlots.indexOf(stolenFeature);
                if (slotIndex !== -1) targetPlayer.boardSlots[slotIndex] = null;
            }
            
            // Add to current player if they have space
            if (gameState.currentPlayer.board.length < 4) {
                const targetSlot = gameState.playerBoard.findIndex(slot => slot === null);
                if (targetSlot !== -1) {
                    gameState.playerBoard[targetSlot] = stolenFeature;
                    gameState.currentPlayer.board = gameState.playerBoard.filter(f => f);
                    
                    const stats = gameState.featureStats.get(stolenFeature);
                    stats.buildSelections++;
                    
                    const botIndicator = targetPlayer.isBot ? ' 🤖' : '';
                    showNotification(`Stole "${stolenFeature}" from ${targetPlayer.name}${botIndicator}!`);
                    
                    // Notify other players/bots that something was stolen from them
                    if (!targetPlayer.isBot) {
                        // If stealing from human player, they would see it in real-time
                        console.log(`Stole "${stolenFeature}" from human player ${targetPlayer.name}`);
                    }
                }
            }
            
            displayPlayerBoard();
            displayOtherPlayers();
        }

        // Enhanced bot stealing - bots can now steal from the human player too
        function startBotBuilding() {
            console.log('Starting bot building phase V2.0...');
            console.log('Current game stage:', gameState.stage);
            
            gameState.players.forEach(player => {
                if (!player.isBot) return;
                
                console.log(`Setting up actions for bot: ${player.name} (ID: ${player.id})`);
                
                const totalActions = 5 + Math.floor(Math.random() * 3);
                
                for (let i = 0; i < totalActions; i++) {
                    const actionDelay = 2000 + (i * 4000) + Math.random() * 2000;
                    
                    setTimeout(() => {
                        console.log(`Checking action ${i + 1} for ${player.name}: stage=${gameState.stage}, board=${player.board.length}/4`);
                        
                        if (gameState.stage === 'stage2' && player.board.length < 4) {
                            console.log(`${player.name} executing action ${i + 1}/${totalActions}`);
                            performSimpleBotAction(player);
                        } else {
                            console.log(`${player.name} skipping action ${i + 1} - stage: ${gameState.stage}, board: ${player.board.length}/4`);
                        }
                    }, actionDelay);
                }
                
                // Add periodic stealing attempts targeting human player specifically
                if (Math.random() > 0.5) { // 50% chance for each bot to target human
                    const stealDelay = 5000 + Math.random() * 20000; // Random time between 5-25 seconds
                    setTimeout(() => {
                        if (gameState.stage === 'stage2' && 
                            player.board.length < 4 && 
                            gameState.currentPlayer.board.length > 0) {
                            
                            console.log(`${player.name} attempting to steal from human player`);
                            performBotStealFromHuman(player);
                        }
                    }, stealDelay);
                }
            });
        }

        function performBotStealFromHuman(bot) {
            if (gameState.currentPlayer.board.length === 0) return;
            
            const stolenFeature = gameState.currentPlayer.board[Math.floor(Math.random() * gameState.currentPlayer.board.length)];
            
            console.log(`${bot.name} stealing "${stolenFeature}" from human player`);
            
            // Move bot cursor to human player's board area
            const playerBoard = document.getElementById('playerBoard');
            if (playerBoard) {
                const rect = playerBoard.getBoundingClientRect();
                const targetX = rect.left + rect.width / 2 + (Math.random() - 0.5) * 100;
                const targetY = rect.top + rect.height / 2 + (Math.random() - 0.5) * 100;
                
                showPlayerActivity(bot.id, 'stealing', stolenFeature);
                animateBotCursor(bot, targetX, targetY, 1500);
                
                setTimeout(() => {
                    updatePlayerCursor(bot.id, {
                        isDragging: true,
                        draggedItem: stolenFeature
                    });
                    
                    // Actually perform the steal
                    gameState.currentPlayer.board = gameState.currentPlayer.board.filter(f => f !== stolenFeature);
                    gameState.playerBoard = gameState.playerBoard.map(f => f === stolenFeature ? null : f);
                    
                    bot.board.push(stolenFeature);
                    if (bot.boardSlots) {
                        const emptySlot = bot.boardSlots.findIndex(slot => slot === null);
                        if (emptySlot !== -1) bot.boardSlots[emptySlot] = stolenFeature;
                    }
                    
                    const stats = gameState.featureStats.get(stolenFeature);
                    if (stats) stats.buildSelections++;
                    
                    showNotification(`${bot.name} 🤖 stole "${stolenFeature}" from you!`, 'error');
                    console.log(`${bot.name} successfully stole "${stolenFeature}" from human player`);
                    
                    displayPlayerBoard();
                    displayOtherPlayers();
                    
                    // Move bot cursor to their own area
                    const botElement = document.querySelector(`[data-player-id="${bot.id}"]`);
                    if (botElement) {
                        const botRect = botElement.getBoundingClientRect();
                        animateBotCursor(bot, botRect.left + botRect.width / 2, botRect.top + botRect.height / 2, 1200);
                    }
                    
                    setTimeout(() => {
                        updatePlayerCursor(bot.id, {
                            isDragging: false,
                            draggedItem: null
                        });
                        showPlayerActivity(bot.id, 'stole', stolenFeature);
                        
                        setTimeout(() => {
                            showPlayerActivity(bot.id, '', '');
                        }, 2000);
                    }, 1200);
                    
                }, 1500);
            }
        }

        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            const bgColor = type === 'error' ? '#dc3545' : '#28a745';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${bgColor};
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                z-index: 1000;
                font-weight: bold;
                max-width: 300px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    document.body.removeChild(notification);
                }
            }, 4000);
        }

        function displayFeaturePool() {
            const pool = document.getElementById('featurePool');
            pool.innerHTML = '';
            
            const shuffled = [...AVAILABLE_FEATURES].sort(() => 0.5 - Math.random());
            
            shuffled.forEach(feature => {
                const tile = document.createElement('div');
                tile.className = 'feature-tile';
                tile.textContent = feature;
                tile.draggable = true;
                tile.onclick = () => addFeatureToBoard(feature);
                
                tile.ondragstart = (e) => {
                    e.dataTransfer.setData('text/plain', feature);
                };
                
                pool.appendChild(tile);
            });
        }

        function displayPlayerBoard() {
            const board = document.getElementById('playerBoard');
            board.innerHTML = '';
            
            for (let i = 0; i < 4; i++) {
                const slot = document.createElement('div');
                slot.className = 'board-slot';
                slot.onclick = () => {
                    if (gameState.playerBoard[i]) {
                        removeFeatureFromBoard(i);
                    }
                };
                
                slot.ondrop = (e) => {
                    e.preventDefault();
                    const feature = e.dataTransfer.getData('text/plain');
                    addFeatureToBoard(feature, i);
                };
                
                slot.ondragover = (e) => {
                    e.preventDefault();
                    slot.classList.add('can-drop');
                };
                
                slot.ondragleave = () => {
                    slot.classList.remove('can-drop');
                };
                
                if (gameState.playerBoard[i]) {
                    slot.classList.add('filled');
                    slot.textContent = gameState.playerBoard[i];
                } else {
                    slot.textContent = 'Drop feature here';
                }
                
                board.appendChild(slot);
            }
        }

        function displayOtherPlayers() {
            const container = document.getElementById('otherPlayers');
            container.innerHTML = '';
            
            gameState.players.forEach(player => {
                if (player.id === gameState.currentPlayer.id) return;
                
                const playerElement = document.createElement('div');
                playerElement.className = 'other-player';
                playerElement.setAttribute('data-player-id', player.id);
                
                const features = player.board.filter(f => f).join(', ') || 'No features yet';
                const botIndicator = player.isBot ? ' 🤖' : '';
                
                playerElement.innerHTML = `
                    <h4>${player.name}${botIndicator}'s Product (${player.board.length}/4)</h4>
                    <div class="other-player-features">${features}</div>
                    <div class="player-activity"></div>
                `;
                
                if (player.board.length > 0) {
                    playerElement.style.cursor = 'pointer';
                    playerElement.onclick = () => {
                        stealRandomFeature(player);
                    };
                } else {
                    playerElement.style.cursor = 'default';
                }
                
                container.appendChild(playerElement);
            });
        }

        function addFeatureToBoard(feature, slotIndex = null) {
            let targetSlot = slotIndex;
            if (targetSlot === null) {
                targetSlot = gameState.playerBoard.findIndex(slot => slot === null);
            }
            
            if (targetSlot === -1) return;
            
            const currentSlot = gameState.playerBoard.findIndex(slot => slot === feature);
            if (currentSlot !== -1) {
                gameState.playerBoard[currentSlot] = null;
            }
            
            gameState.playerBoard[targetSlot] = feature;
            gameState.currentPlayer.board = gameState.playerBoard.filter(f => f);
            
            const stats = gameState.featureStats.get(feature);
            stats.buildSelections++;
            
            displayPlayerBoard();
            displayOtherPlayers();
        }

        function removeFeatureFromBoard(slotIndex) {
            gameState.playerBoard[slotIndex] = null;
            gameState.currentPlayer.board = gameState.playerBoard.filter(f => f);
            displayPlayerBoard();
        }

        function showPlayerActivity(playerId, action, feature) {
            const activity = gameState.playerActivities.get(playerId);
            if (activity) {
                activity.action = action;
                activity.feature = feature;
                activity.lastUpdate = Date.now();
                
                const playerElement = document.querySelector(`[data-player-id="${playerId}"]`);
                if (playerElement) {
                    const activityElement = playerElement.querySelector('.player-activity');
                    
                    if (activityElement) {
                        let text = '';
                        switch (action) {
                            case 'looking':
                                text = 'Looking for features...';
                                break;
                            case 'grabbing':
                                text = `Grabbing "${feature}"...`;
                                break;
                            case 'stealing':
                                text = `Stealing "${feature}"...`;
                                break;
                            case 'added':
                                text = `Added "${feature}"`;
                                break;
                            case 'stole':
                                text = `Stole "${feature}"`;
                                break;
                            default:
                                text = '';
                        }
                        activityElement.textContent = text;
                    }
                }
            }
        }

        function stealRandomFeature(targetPlayer) {
            if (targetPlayer.board.length === 0) return;
            
            const randomIndex = Math.floor(Math.random() * targetPlayer.board.length);
            const stolenFeature = targetPlayer.board[randomIndex];
            
            targetPlayer.board.splice(randomIndex, 1);
            if (targetPlayer.boardSlots) {
                const slotIndex = targetPlayer.boardSlots.indexOf(stolenFeature);
                if (slotIndex !== -1) targetPlayer.boardSlots[slotIndex] = null;
            }
            
            if (gameState.currentPlayer.board.length < 4) {
                const targetSlot = gameState.playerBoard.findIndex(slot => slot === null);
                if (targetSlot !== -1) {
                    gameState.playerBoard[targetSlot] = stolenFeature;
                    gameState.currentPlayer.board = gameState.playerBoard.filter(f => f);
                    
                    const stats = gameState.featureStats.get(stolenFeature);
                    stats.buildSelections++;
                }
            }
            
            displayPlayerBoard();
            displayOtherPlayers();
            
            const botIndicator = targetPlayer.isBot ? ' 🤖' : '';
            showNotification(`Stole "${stolenFeature}" from ${targetPlayer.name}${botIndicator}!`);
        }

        function showNotification(message) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #28a745;
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                z-index: 1000;
                font-weight: bold;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    document.body.removeChild(notification);
                }
            }, 3000);
        }

        function startTimer(seconds, elementId, callback) {
            gameState.timeLeft = seconds;
            const timerElement = document.getElementById(elementId);
            
            gameState.timer = setInterval(() => {
                gameState.timeLeft--;
                timerElement.textContent = `Time remaining: ${gameState.timeLeft}s`;
                
                if (gameState.timeLeft <= 0) {
                    clearInterval(gameState.timer);
                    callback();
                }
            }, 1000);
        }

        function endBuildingPhase() {
            const cursorOverlay = document.getElementById('cursorOverlay');
            if (cursorOverlay) {
                cursorOverlay.innerHTML = '';
            }
            
            gameState.playerActivities.clear();
            gameState.playerCursors.clear();
            
            calculateScores();
            document.getElementById('stage2').classList.remove('active');
            document.getElementById('results').classList.add('active');
            displayResults();
        }

        function calculateScores() {
            gameState.players.forEach(player => {
                let score = 0;
                
                player.board.forEach(feature => {
                    if (feature) {
                        const stats = gameState.featureStats.get(feature);
                        const hotness = stats.conjointSelections * 10 + stats.buildSelections * 5;
                        score += hotness;
                    }
                });
                
                player.score = score;
            });
        }

        function displayResults() {
            const sortedPlayers = Array.from(gameState.players.values())
                .sort((a, b) => b.score - a.score);
            
            const leaderboard = document.getElementById('leaderboard');
            leaderboard.innerHTML = '<h3>Final Leaderboard</h3>';
            
            sortedPlayers.forEach((player, index) => {
                const item = document.createElement('div');
                item.className = `leaderboard-item ${index === 0 ? 'winner' : index === 1 ? 'second' : index === 2 ? 'third' : ''}`;
                
                const position = index + 1;
                const medal = position === 1 ? '🏆' : position === 2 ? '🥈' : position === 3 ? '🥉' : '';
                
                item.innerHTML = `
                    <div>
                        <span style="font-size: 1.5rem;">${medal}</span>
                        <strong>${player.name}</strong>
                        <div style="font-size: 0.9rem; color: #666;">
                            Features: ${player.board.join(', ') || 'None'}
                        </div>
                    </div>
                    <div class="player-score">${player.score} pts</div>
                `;
                
                leaderboard.appendChild(item);
            });
            
            displayFeatureStats();
        }

        function displayFeatureStats() {
            const statsContainer = document.getElementById('featureStats');
            statsContainer.innerHTML = '';
            
            const sortedFeatures = Array.from(gameState.featureStats.entries())
                .sort(([,a], [,b]) => (b.conjointSelections + b.buildSelections) - (a.conjointSelections + a.buildSelections))
                .slice(0, 8);
            
            sortedFeatures.forEach(([feature, stats]) => {
                const statItem = document.createElement('div');
                statItem.className = 'stat-item';
                
                const totalSelections = stats.conjointSelections + stats.buildSelections;
                
                statItem.innerHTML = `
                    <div class="stat-value">${totalSelections}</div>
                    <div>${feature}</div>
                    <div style="font-size: 0.8rem; color: #666;">
                        ${stats.conjointSelections} conjoint, ${stats.buildSelections} build
                    </div>
                `;
                
                statsContainer.appendChild(statItem);
            });
        }

        function newGame() {
            if (gameState.timer) {
                clearInterval(gameState.timer);
            }
            if (gameState.countdownTimer) {
                clearInterval(gameState.countdownTimer);
            }
            
            const cursorOverlay = document.getElementById('cursorOverlay');
            if (cursorOverlay) {
                cursorOverlay.innerHTML = '';
            }
            
            gameState.players.forEach(player => {
                player.score = 0;
                player.board = [];
                player.conjointChoice = null;
                player.boardSlots = player.isBot ? Array(4).fill(null) : undefined;
            });
            
            gameState.playerActivities.clear();
            gameState.playerCursors.clear();
            gameState.stage = 'waiting';
            gameState.selectedOption = null;
            gameState.playerBoard = [];
            gameState.isDragging = false;
            gameState.draggedFeature = null;
            
            AVAILABLE_FEATURES.forEach(feature => {
                gameState.featureStats.set(feature, { conjointSelections: 0, buildSelections: 0 });
            });
            
            document.getElementById('waitingRoom').style.display = 'block';
            document.getElementById('stage1').classList.remove('active');
            document.getElementById('stage2').classList.remove('active');
            document.getElementById('results').classList.remove('active');
            
            document.getElementById('progressBar').style.width = '0%';
            
            updateWaitingRoom();
            
            if (gameState.isAdmin) {
                startCountdown();
            }
        }

        // Initialize the game
        window.onload = function() {
            console.log('=== FRESH GAME VERSION 2.0 LOADED ===');
            console.log('Initial game stage:', gameState.stage);
        };
    </script>
</body>
</html>